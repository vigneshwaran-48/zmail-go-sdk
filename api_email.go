/*
Zoho Mail API

This is a Zoho Mail API OpenAPI 3.0 specification

API version: 1.0.0
Contact: vigneshwaran4817@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package zmail

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EmailAPIService EmailAPI service
type EmailAPIService service

type ApiGetMessageContentRequest struct {
	ctx context.Context
	ApiService *EmailAPIService
	accountId string
	folderId string
	messageId string
	includeBlockContent *bool
}

func (r ApiGetMessageContentRequest) IncludeBlockContent(includeBlockContent bool) ApiGetMessageContentRequest {
	r.includeBlockContent = &includeBlockContent
	return r
}

func (r ApiGetMessageContentRequest) Execute() (*EmailContentResponse, *http.Response, error) {
	return r.ApiService.GetMessageContentExecute(r)
}

/*
GetMessageContent Retrives the content of email

This API is used to retrieve the message contents of an email based on the message ID passed in the request URL. In case, you retrieve an email from a thread, you can add the includeBlockContent parameter to get the reply email and the parent email separately. If block content is available but the includeBlockContent parameter is not passed, then the original email content can only be retrieved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId This key is used to identify the account from which the folders have to be fetched. It is generated during account addition.
 @param folderId This key is used to identify the folder to be used.
 @param messageId This key is used to identify the message to be used.
 @return ApiGetMessageContentRequest
*/
func (a *EmailAPIService) GetMessageContent(ctx context.Context, accountId string, folderId string, messageId string) ApiGetMessageContentRequest {
	return ApiGetMessageContentRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		folderId: folderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return EmailContentResponse
func (a *EmailAPIService) GetMessageContentExecute(r ApiGetMessageContentRequest) (*EmailContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailAPIService.GetMessageContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts/{accountId}/folders/{folderId}/messages/{messageId}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeBlockContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeBlockContent", r.includeBlockContent, "form", "")
	} else {
		var defaultValue bool = false
		r.includeBlockContent = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageDetailsRequest struct {
	ctx context.Context
	ApiService *EmailAPIService
	accountId string
	folderId string
	messageId string
}

func (r ApiGetMessageDetailsRequest) Execute() (*EmailResponse, *http.Response, error) {
	return r.ApiService.GetMessageDetailsExecute(r)
}

/*
GetMessageDetails Retrives the message details

The API retrieves the metadata information of an email based on the message ID passed in the request URL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId This key is used to identify the account from which the folders have to be fetched. It is generated during account addition.
 @param folderId This key is used to identify the folder to be used.
 @param messageId This key is used to identify the message to be used.
 @return ApiGetMessageDetailsRequest
*/
func (a *EmailAPIService) GetMessageDetails(ctx context.Context, accountId string, folderId string, messageId string) ApiGetMessageDetailsRequest {
	return ApiGetMessageDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		folderId: folderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return EmailResponse
func (a *EmailAPIService) GetMessageDetailsExecute(r ApiGetMessageDetailsRequest) (*EmailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailAPIService.GetMessageDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts/{accountId}/folders/{folderId}/messages/{messageId}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageHeaderRequest struct {
	ctx context.Context
	ApiService *EmailAPIService
	accountId string
	folderId string
	messageId string
	raw *bool
}

func (r ApiGetMessageHeaderRequest) Raw(raw bool) ApiGetMessageHeaderRequest {
	r.raw = &raw
	return r
}

func (r ApiGetMessageHeaderRequest) Execute() (*GetMessageHeader200Response, *http.Response, error) {
	return r.ApiService.GetMessageHeaderExecute(r)
}

/*
GetMessageHeader Retrives message headers

The API retrieves the internet message headers of a particular email, based on the message ID passed as the request parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId This key is used to identify the account from which the folders have to be fetched. It is generated during account addition.
 @param folderId This key is used to identify the folder to be used.
 @param messageId This key is used to identify the message to be used.
 @return ApiGetMessageHeaderRequest
*/
func (a *EmailAPIService) GetMessageHeader(ctx context.Context, accountId string, folderId string, messageId string) ApiGetMessageHeaderRequest {
	return ApiGetMessageHeaderRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		folderId: folderId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return GetMessageHeader200Response
func (a *EmailAPIService) GetMessageHeaderExecute(r ApiGetMessageHeaderRequest) (*GetMessageHeader200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMessageHeader200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailAPIService.GetMessageHeader")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts/{accountId}/folders/{folderId}/messages/{messageId}/header"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterValueToString(r.folderId, "folderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.raw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "raw", r.raw, "form", "")
	} else {
		var defaultValue bool = true
		r.raw = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOriginalMessageRequest struct {
	ctx context.Context
	ApiService *EmailAPIService
	accountId string
	messageId string
}

func (r ApiGetOriginalMessageRequest) Execute() (*EmailContentResponse, *http.Response, error) {
	return r.ApiService.GetOriginalMessageExecute(r)
}

/*
GetOriginalMessage Retrives the original content of email

This API retrieves the MIME representation of an email message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId This key is used to identify the account from which the folders have to be fetched. It is generated during account addition.
 @param messageId This key is used to identify the message to be used.
 @return ApiGetOriginalMessageRequest
*/
func (a *EmailAPIService) GetOriginalMessage(ctx context.Context, accountId string, messageId string) ApiGetOriginalMessageRequest {
	return ApiGetOriginalMessageRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return EmailContentResponse
func (a *EmailAPIService) GetOriginalMessageExecute(r ApiGetOriginalMessageRequest) (*EmailContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailAPIService.GetOriginalMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts/{accountId}/messages/{messageId}/originalmessage"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListEmailsRequest struct {
	ctx context.Context
	ApiService *EmailAPIService
	accountId string
	folderId *int64
	start *int32
	limit *int32
	status *string
	flagid *int32
	labelid *int64
	threadId *int64
	sortBy *string
	sortorder *bool
	includeto *bool
	includesent *bool
	includearchive *bool
	attachedMails *bool
	inlinedMails *bool
	flaggedMails *bool
	respondedMails *bool
	threadedMails *bool
}

// The unique identifier for the folder from which the emails need to be retrieved. This can be fetched using the Get all folders API.
func (r ApiListEmailsRequest) FolderId(folderId int64) ApiListEmailsRequest {
	r.folderId = &folderId
	return r
}

// The starting sequence number of the emails to be retrieved.
func (r ApiListEmailsRequest) Start(start int32) ApiListEmailsRequest {
	r.start = &start
	return r
}

// The number of emails to be retrieved from the start value mentioned. Allowed values:- Min. value:- 1 and max. value:- 200.
func (r ApiListEmailsRequest) Limit(limit int32) ApiListEmailsRequest {
	r.limit = &limit
	return r
}

// Retrieve emails by read or unread status.
func (r ApiListEmailsRequest) Status(status string) ApiListEmailsRequest {
	r.status = &status
	return r
}

// The unique identifier for the flag used to retrieve emails based on a specific flag type.
func (r ApiListEmailsRequest) Flagid(flagid int32) ApiListEmailsRequest {
	r.flagid = &flagid
	return r
}

// The unique identifier for the label used to retrieve emails based on a specific label.
func (r ApiListEmailsRequest) Labelid(labelid int64) ApiListEmailsRequest {
	r.labelid = &labelid
	return r
}

// The unique identifier for the flag used to retrieve emails of the given threadId.
func (r ApiListEmailsRequest) ThreadId(threadId int64) ApiListEmailsRequest {
	r.threadId = &threadId
	return r
}

// The basis on which the sorting of the list of emails should be done.
func (r ApiListEmailsRequest) SortBy(sortBy string) ApiListEmailsRequest {
	r.sortBy = &sortBy
	return r
}

// The order in which the sorting of the list of emails should be done.
func (r ApiListEmailsRequest) Sortorder(sortorder bool) ApiListEmailsRequest {
	r.sortorder = &sortorder
	return r
}

// Whether to details need to be included or not on the list of emails retrieved.
func (r ApiListEmailsRequest) Includeto(includeto bool) ApiListEmailsRequest {
	r.includeto = &includeto
	return r
}

// Whether sent emails need to be included or not on the list of emails retrieved.
func (r ApiListEmailsRequest) Includesent(includesent bool) ApiListEmailsRequest {
	r.includesent = &includesent
	return r
}

// Whether archived emails need to be included or not on the list of emails retrieved.
func (r ApiListEmailsRequest) Includearchive(includearchive bool) ApiListEmailsRequest {
	r.includearchive = &includearchive
	return r
}

// Retrieve only the emails with attachments.
func (r ApiListEmailsRequest) AttachedMails(attachedMails bool) ApiListEmailsRequest {
	r.attachedMails = &attachedMails
	return r
}

// Retrieve only the emails with inline images.
func (r ApiListEmailsRequest) InlinedMails(inlinedMails bool) ApiListEmailsRequest {
	r.inlinedMails = &inlinedMails
	return r
}

// Retrieve only flagged emails.
func (r ApiListEmailsRequest) FlaggedMails(flaggedMails bool) ApiListEmailsRequest {
	r.flaggedMails = &flaggedMails
	return r
}

// Retrieve only emails with replies.
func (r ApiListEmailsRequest) RespondedMails(respondedMails bool) ApiListEmailsRequest {
	r.respondedMails = &respondedMails
	return r
}

// Retrieve emails that are a part of conversations.
func (r ApiListEmailsRequest) ThreadedMails(threadedMails bool) ApiListEmailsRequest {
	r.threadedMails = &threadedMails
	return r
}

func (r ApiListEmailsRequest) Execute() (*EmailsResponse, *http.Response, error) {
	return r.ApiService.ListEmailsExecute(r)
}

/*
ListEmails Retrieves emails

The API retrieves a list of all the emails in a specific folder or a list of emails based on predefined conditions like status/flags/labels, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId This key is used to identify the account from which the folders have to be fetched. It is generated during account addition.
 @return ApiListEmailsRequest
*/
func (a *EmailAPIService) ListEmails(ctx context.Context, accountId string) ApiListEmailsRequest {
	return ApiListEmailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EmailsResponse
func (a *EmailAPIService) ListEmailsExecute(r ApiListEmailsRequest) (*EmailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailAPIService.ListEmails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts/{accountId}/messages/view"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.folderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folderId", r.folderId, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 1
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "all"
		r.status = &defaultValue
	}
	if r.flagid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flagid", r.flagid, "form", "")
	}
	if r.labelid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelid", r.labelid, "form", "")
	}
	if r.threadId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threadId", r.threadId, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	} else {
		var defaultValue string = "date"
		r.sortBy = &defaultValue
	}
	if r.sortorder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortorder", r.sortorder, "form", "")
	} else {
		var defaultValue bool = false
		r.sortorder = &defaultValue
	}
	if r.includeto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeto", r.includeto, "form", "")
	} else {
		var defaultValue bool = false
		r.includeto = &defaultValue
	}
	if r.includesent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includesent", r.includesent, "form", "")
	} else {
		var defaultValue bool = false
		r.includesent = &defaultValue
	}
	if r.includearchive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includearchive", r.includearchive, "form", "")
	} else {
		var defaultValue bool = false
		r.includearchive = &defaultValue
	}
	if r.attachedMails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachedMails", r.attachedMails, "form", "")
	} else {
		var defaultValue bool = false
		r.attachedMails = &defaultValue
	}
	if r.inlinedMails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inlinedMails", r.inlinedMails, "form", "")
	} else {
		var defaultValue bool = false
		r.inlinedMails = &defaultValue
	}
	if r.flaggedMails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flaggedMails", r.flaggedMails, "form", "")
	} else {
		var defaultValue bool = false
		r.flaggedMails = &defaultValue
	}
	if r.respondedMails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "respondedMails", r.respondedMails, "form", "")
	} else {
		var defaultValue bool = false
		r.respondedMails = &defaultValue
	}
	if r.threadedMails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threadedMails", r.threadedMails, "form", "")
	} else {
		var defaultValue bool = false
		r.threadedMails = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchEmailsRequest struct {
	ctx context.Context
	ApiService *EmailAPIService
	accountId string
	searchKey *string
	receivedTime *int64
	start *int32
	limit *int32
	includeto *bool
}

// Specifies the search criteria. Ensure that the searchKey is constructed using the search syntax defined in this help page. For example:- To search for new emails, provide the searchKey as newMails.
func (r ApiSearchEmailsRequest) SearchKey(searchKey string) ApiSearchEmailsRequest {
	r.searchKey = &searchKey
	return r
}

// Specifies the time before which emails were received. It allows users to filter emails based on their received timestamp. Format:- Unix timestamp in milliseconds. Example:- 1609459200000. By default, the API retrieves emails received before 2 minutes from the current time unless a specific timestamp is provided.
func (r ApiSearchEmailsRequest) ReceivedTime(receivedTime int64) ApiSearchEmailsRequest {
	r.receivedTime = &receivedTime
	return r
}

// Specifies the starting sequence number of the emails to be retrieved.
func (r ApiSearchEmailsRequest) Start(start int32) ApiSearchEmailsRequest {
	r.start = &start
	return r
}

// Specifies the number of emails to be retrieved from the start value mentioned. Allowed values:- Min. value:- 1 and max. value:- 200.
func (r ApiSearchEmailsRequest) Limit(limit int32) ApiSearchEmailsRequest {
	r.limit = &limit
	return r
}

// Specifies whether To details need to be included or not on the list of emails retrieved.
func (r ApiSearchEmailsRequest) Includeto(includeto bool) ApiSearchEmailsRequest {
	r.includeto = &includeto
	return r
}

func (r ApiSearchEmailsRequest) Execute() (*EmailsResponse, *http.Response, error) {
	return r.ApiService.SearchEmailsExecute(r)
}

/*
SearchEmails Searches emails

The API retrieves the list of emails, based on the custom search terms and parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId This key is used to identify the account from which the folders have to be fetched. It is generated during account addition.
 @return ApiSearchEmailsRequest
*/
func (a *EmailAPIService) SearchEmails(ctx context.Context, accountId string) ApiSearchEmailsRequest {
	return ApiSearchEmailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return EmailsResponse
func (a *EmailAPIService) SearchEmailsExecute(r ApiSearchEmailsRequest) (*EmailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EmailAPIService.SearchEmails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/accounts/{accountId}/messages/search"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchKey == nil {
		return localVarReturnValue, nil, reportError("searchKey is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "searchKey", r.searchKey, "form", "")
	if r.receivedTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receivedTime", r.receivedTime, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 1
		r.start = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.includeto != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeto", r.includeto, "form", "")
	} else {
		var defaultValue bool = false
		r.includeto = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
